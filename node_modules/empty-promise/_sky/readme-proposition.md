The README for `empty-promise` is disparaging. It would lead anyone who stumbles onto it to believe its not worth their time to even try it. I think that is completely wrong. I believe this minimalistic tool can be the basis of a coding style that makes Promises much more intuitive to work with and easier to read and maintain.

I propose changing README to be, 1. a promotional tool, encouraging passersby to stop and take a real look, and 2. a list of enough basic recipes to actually understand how and when someone might use it.

---
In a prior message, @olalonde gave me an example of wrappig a node api as a time when "native promise API is generally sufficient". I'm sorry, but "generally sufficient" is a pretty low bar. Larger, more convoluted versions of this type of code is exactly the type of thing first got me itching for empty promises.

Using the results of promises that somebody else wrote is lovely and simple, especially when compared to deep callback nests. But every time I go to write a new promise myself I get an icky feeling. Why does everything need to be wrapped. Conceptually, a promise is just supposed to be an IOU for a future value, but in practice, these promises are giant state-machines packed full of all the logic in an application hooked together in a one-directional pipeline.

So let's take olalonde's code example and examine how an empty promise might be used as a real solution instead of a convenience in edge cases.

Here is the code from olalonde's example:

```javascript

const promisifiedFunction = (...args) => Promise((resolve, reject) => {
  someNodebackFunction(...args, (err, result) => {
    if (err) return reject(err)
    resolve(result)
  })
})
```
Here is the same function rewritten with an empty promise
```javascript

const emptyPromise = require('empty-promise')

const promisifiedFunction = (...args) => {
   const promise = emptyPromise()

   someNodebackFunction(...args, (err, result)=> {
     if (err) promise.reject(err)
     promise.resolve(result)
   })
   return promise
}
```
At first glance, the difference is hardly noticeable. The new one is a little flatter, but a few more lines. But look closer?

In the first example, the Promise is this big state machine that's big enough to hold your function, your data, and any results that come back, all while keeping track of resolution state and anybody who's subscribed to it's `.then()` method. This tiny example _literally_ does nothing, but it already looks kind of intimidating.

The visual style of the promise mirrors its behavior. Even after compressing it down with a fat-arrow and a missing `new` keyword, the Promise constructor still sticks way off to the right side of the rest of your code to let you know it's here to control you. ðŸ˜ˆ

In the second example, the promise is no longer a container for the whole function. The empty promise is merely a token that can be resolved by anyone at any time. All this token knows is that sometime in the future there will be `some value` available from calling it's `.then()` method, and anyone who tries to ask for the value before it's ready will get queued up to receive the result later. An empty promise doesn't need to know anything at all about where its value will come from, only whether it exists yet.

In this case we call `someNodebackFunction` to pay the dividend and let that function resolve it. But we could just as easily do something else with it, like maybe hand it off to a test. The code test can easily and simply resolve the promise for us with zero understanding of `someNodebackFunction` because it's just a token promising a value and nothing more.

What if instead of just promisifying we wanted to invert control, for even better testability? Well, because the promise is just a token for a future value instead of a container for business logic, this is easy.

```javascript

// Inverted control factory takes the node function and a promise
//  as dependencies. So we can stub the node function and create
//  the promise inside our test.

const makeInvertedNodeback = ({
  someNodebackFunction,
  promise
})=> (...args)=> {

  someNodebackFunction(...args, (err, result)=> {
    if (err) promise.reject(err)
    promise.resolve(result)
  })

  return promise
}

//  get our dependencies
const someNodebackFunction = (...args, cb)=> {
  cb(null, ...args)
}
const somePromise = emptyPromise()

// We subscribed to the `then` method before we even connected
//  the promise to any logic. It's like  having a 'ready'
//  listener for the resolved value. This will be a separate
//  promise chain from any other .then() call
somePromise.then(console.log, console.error)

// now our nodeback is both inverterted and promisified
invertedNodeback = makeInvertedNodeback({
  promise: somePromise,
  someNodebackFunction
})

invertedNodeback('some value')
  .then(val=> console.log('result',val))
  .catch(console.error)


```
